# Versió RC00
esphome:
  name: multiIR
  platform: ESP32
  board: esp32dev

  # APLICACIÓ DINÀMICA d'IP ESTÀTICA a ETH i (opcional) STA Wi‑Fi a l'arrencada
  # ip: Ip ethernet
  # gw: Gateway ethernet
  # sn: subnet Mascara red ethernet
  # dns: servidor dns ethernet
  on_boot:
    priority: 600
    then:
      - lambda: |-
          // ----- Ethernet: IP estàtica si hi ha valors guardats -----
          if (id(new_ip).length() > 0 && id(new_gateway).length() > 0 && id(new_subnet).length() > 0) {
            IPAddress ip, gw, sn, dns;
            bool ok_ip = ip.fromString(id(new_ip).c_str());
            bool ok_gw = gw.fromString(id(new_gateway).c_str());
            bool ok_sn = sn.fromString(id(new_subnet).c_str());
            bool ok_dns = id(new_dns).length() ? dns.fromString(id(new_dns).c_str()) : false;

            if (ok_ip && ok_gw && ok_sn) {
              if (ok_dns) {
                ETH.config(ip, gw, sn, dns);
                ESP_LOGI("net", "ETH.config(IP=%s, GW=%s, SN=%s, DNS=%s) aplicat",
                         id(new_ip).c_str(), id(new_gateway).c_str(),
                         id(new_subnet).c_str(), id(new_dns).c_str());
              } else {
                ETH.config(ip, gw, sn);
                ESP_LOGI("net", "ETH.config(IP=%s, GW=%s, SN=%s) aplicat",
                         id(new_ip).c_str(), id(new_gateway).c_str(),
                         id(new_subnet).c_str());
              }
            } else {
              ESP_LOGW("net", "Formats IP/GW/SN invàlids. Deixem DHCP.");
            }
          } else {
            ESP_LOGI("net", "DHCP (cap IP/gateway/subnet guardat)");
          }

          // ----- Wi‑Fi STA opcional com a backup si s'ha configurat -----
          if (id(new_ssid).length() > 0) {
            WiFi.mode(WIFI_STA);
            WiFi.begin(id(new_ssid).c_str(), id(new_password).c_str());
            ESP_LOGI("wifi", "Intentant STA amb SSID=%s", id(new_ssid).c_str());
          }

logger:

api:
  encryption:
    key: !secret api_key

ota:
  - platform: esphome
    password: !secret ota_password
    
# ---------- Globals persistents per config de xarxa ----------
globals:
  - id: new_ssid
    type: std::string
    restore_value: yes
    initial_value: ""
  - id: new_password
    type: std::string
    restore_value: yes
    initial_value: ""
  - id: new_ip
    type: std::string
    restore_value: yes
    initial_value: ""
  - id: new_gateway
    type: std::string
    restore_value: yes
    initial_value: ""
  - id: new_subnet
    type: std::string
    restore_value: yes
    initial_value: ""
  - id: new_dns
    type: std::string
    restore_value: yes
    initial_value: ""

# ---------- Ethernet principal (WT32‑ETH01: LAN8720) ----------
ethernet:
  type: LAN8720
  mdc_pin: GPIO23
  mdio_pin: GPIO18
  clk_mode: GPIO0_IN
  phy_addr: 1
  power_pin: GPIO16
  # DHCP per defecte; si hi ha IP guardada, s'aplica a on_boot via ETH.config()

# ---------- Wi‑Fi només com AP de configuració ----------
wifi:
  ap:
    ssid: "multiIR-setup"
    password: "12345678"

captive_portal:

# ---------- Pàgina web de configuració (IP, GW, SN, DNS, SSID/PASS) ----------
web_server:
  port: 80
  include_internal: true
  on_request:
    - lambda: |-
        if (request->url() == "/" || request->url() == "/index") {
          std::string html = R"HTML(
            <html><head><title>multiIR Config</title>
            <style>body{font-family:Arial;margin:24px}input{padding:6px;margin:6px 0;width:280px}.btn{padding:8px 14px;background:#0069d9;color:#fff;border:none;cursor:pointer}.btn-red{background:#c9302c}</style>
            </head><body>
            <h1>Configuració de Xarxa (WT32-ETH01)</h1>
            <p>Ethernet: DHCP per defecte. Si introdueixes IP/Gateway/Subnet/DNS, s'aplicarà estàtica en el proper reinici.</p>
            <h2>Estat guardat</h2>
            <ul>
              <li>IP: )HTML";
          html += id(new_ip).length() ? id(new_ip) : std::string("(DHCP)");
          html += R"HTML(</li><li>Gateway: )HTML";
          html += id(new_gateway).length() ? id(new_gateway) : std::string("(no)");
          html += R"HTML(</li><li>Subnet: )HTML";
          html += id(new_subnet).length() ? id(new_subnet) : std::string("(no)");
          html += R"HTML(</li><li>DNS: )HTML";
          html += id(new_dns).length() ? id(new_dns) : std::string("(no)");
          html += R"HTML(</li></ul>
            <h2>Formulari</h2>
            /config
              <h3>Ethernet (opcional: IP estàtica)</h3>
              IP: <input type="text" name="ip" placeholder="192.168.1.50"><br>
              Gateway: <input type="text" name="gw" placeholder="192.168.1.1"><br>
              Subnet: <input type="text" name="sn" placeholder="255.255.255.0"><br>
              DNS: <input type="text" name="dns" placeholder="8.8.8.8"><br>
              <h3>Wi‑Fi STA (opcional)</h3>
              SSID: <input type="text" name="ssid" placeholder="NomWiFi"><br>
              Password: <input type="text" name="pass" placeholder="Contrasenya"><br>
              <input class="btn" type="submit" value="Guardar i reiniciar">
            </form>
            <hr>
            /dhcp
              <input class="btn btn-red" type="submit" value="Tornar a DHCP (neteja IP)">
            </form>
            </body></html>
          )HTML";
          request->send(200, "text/html", html);
          return;
        }

        if (request->url() == "/config") {
          if (request->has_param("ip"))   id(new_ip) = request->get_param("ip").c_str();
          if (request->has_param("gw"))   id(new_gateway) = request->get_param("gw").c_str();
          if (request->has_param("sn"))   id(new_subnet) = request->get_param("sn").c_str();
          if (request->has_param("dns"))  id(new_dns) = request->get_param("dns").c_str();
          if (request->has_param("ssid")) id(new_ssid) = request->get_param("ssid").c_str();
          if (request->has_param("pass")) id(new_password) = request->get_param("pass").c_str();

          request->send(200, "text/html", "<h1>Configuració guardada. Reiniciant...</h1>");
          ESP_LOGI("net", "Guardat: IP=%s, GW=%s, SN=%s, DNS=%s, SSID=%s",
                   id(new_ip).c_str(), id(new_gateway).c_str(),
                   id(new_subnet).c_str(), id(new_dns).c_str(),
                   id(new_ssid).c_str());
          delay(1500);
          ESP.restart();
          return;
        }

        if (request->url() == "/dhcp") {
          id(new_ip) = ""; id(new_gateway) = ""; id(new_subnet) = ""; id(new_dns) = "";
          request->send(200, "text/html", "<h1>S'ha establert DHCP. Reiniciant...</h1>");
          ESP_LOGI("net", "DHCP activat (valors netejats)");
          delay(1200);
          ESP.restart();
          return;
        }

        request->send(404, "text/plain", "Not Found");

# ---------- Sensors d'estat d'IP actual ----------
text_sensor:
  - platform: template
    name: "IP Ethernet actual"
    update_interval: 5s
    lambda: |-
      return ETH.localIP().toString().c_str();
  - platform: template
    name: "IP Wi‑Fi actual"
    update_interval: 5s
    lambda: |-
      return WiFi.localIP().toString().c_str();

# =========================================================
# =                BLOC IR MULTI-SORTIDA                 =
# =========================================================

# Globals de selecció
globals:
  - id: selected_tv
    type: int
    restore_value: no
    initial_value: '1'        # TV1 per defecte

# Guardem quatre valors de protocol    
  - id: protocol_tv1
    type: int
    restore_value: yes
    initial_value: '3'        # 1=NEC, 2=RC5, 3=RC6 (per defecte RC6)
  - id: protocol_tv2
    type: int
    restore_value: yes
    initial_value: '3'        # 1=NEC, 2=RC5, 3=RC6 (per defecte RC6)   
  - id: protocol_tv3
    type: int
    restore_value: yes
    initial_value: '3'        # 1=NEC, 2=RC5, 3=RC6 (per defecte RC6) 
  - id: protocol_tv4
    type: int
    restore_value: yes
    initial_value: '3'        # 1=NEC, 2=RC5, 3=RC6 (per defecte RC6) 
    
  - id: selected_function
    type: int
    restore_value: no
    initial_value: '1'        # Funció 1 per defecte
    

# QUATRE emissors IR
remote_transmitter:
  - id: ir_tv1
    pin: GPIO14     # GPIO per TV1
    carrier_duty_percent: 50%
  - id: ir_tv2
    pin: GPIO12     # GPIO per TV2
    carrier_duty_percent: 50%
  - id: ir_tv3
    pin: GPIO04     # GPIO per TV3
    carrier_duty_percent: 50%
  - id: ir_tv4
    pin: GPIO02     # GPIO per TV4
    carrier_duty_percent: 50%

# -------------------------------
# Botons: Selecció de TV (4)
# -------------------------------
button:
  - platform: template
    name: "Selecciona TV1"
    id: sel_tv_1
    on_press: { then: [globals.set: {id: selected_tv, value: '1'} ] }
  - platform: template
    name: "Selecciona TV2"
    id: sel_tv_2
    on_press: { then: [globals.set: {id: selected_tv, value: '2'} ] }
  - platform: template
    name: "Selecciona TV3"
    id: sel_tv_3
    on_press: { then: [globals.set: {id: selected_tv, value: '3'} ] }
  - platform: template
    name: "Selecciona TV4"
    id: sel_tv_4
    on_press: { then: [globals.set: {id: selected_tv, value: '4'} ] }

# -------------------------------
# Botons: Selecció de protocol (8)
# 1=NEC, 2=RC5, 3=RC6, 4..8 placeholders
# -------------------------------
  - platform: template
    name: "Protocol NEC"
    id: P01
    on_press:
      then:
        - lambda: |-
            if (id(selected_tv) = 1) {
            id(protocol_tv1) == 1;
            } else if (id(selected_tv) = 2) {
            id(protocol_tv2) == 1;
            } else if (id(selected_tv) = 3) {
            id(protocol_tv3) == 1;
            } else if (id(selected_tv) = 4) {
            id(protocol_tv4) == 1}

  - platform: template
    name: "Protocol RC5"
    id: P02
    on_press:
      then:
        - lambda: |-
            if (id(selected_tv) = 1) {
            id(protocol_tv1) == 2;
            } else if (id(selected_tv) = 2) {
            id(protocol_tv2) == 2;
            } else if (id(selected_tv) = 3) {
            id(protocol_tv3) == 2;
            } else if (id(selected_tv) = 4) {
            id(protocol_tv4) == 2}

  - platform: template
    name: "Protocol RC6"
    id: P03
    on_press:
      then:
        - lambda: |-
            if (id(selected_tv) = 1) {
            id(protocol_tv1) == 3;
            } else if (id(selected_tv) = 2) {
            id(protocol_tv2) == 3;
            } else if (id(selected_tv) = 3) {
            id(protocol_tv3) == 3;
            } else if (id(selected_tv) = 4) {
            id(protocol_tv4) == 3}

  - platform: template
    name: "Protocol Sony"
    id: P04
    on_press:
      then:
        - lambda: |-
            if (id(selected_tv) = 1) {
            id(protocol_tv1) == 4;
            } else if (id(selected_tv) = 2) {
            id(protocol_tv2) == 4;
            } else if (id(selected_tv) = 3) {
            id(protocol_tv3) == 4;
            } else if (id(selected_tv) = 4) {
            id(protocol_tv4) == 4}            

  - platform: template
    name: "Protocol Samsung"
    id: P05
    on_press:
      then:
        - lambda: |-
            if (id(selected_tv) = 1) {
            id(protocol_tv1) == 5;
            } else if (id(selected_tv) = 2) {
            id(protocol_tv2) == 5;
            } else if (id(selected_tv) = 3) {
            id(protocol_tv3) == 5;
            } else if (id(selected_tv) = 4) {
            id(protocol_tv4) == 5}            
                      
  - platform: template
    name: "Protocol LG"
    id: P06
    on_press:
      then:
        - lambda: |-
            if (id(selected_tv) = 1) {
            id(protocol_tv1) == 6;
            } else if (id(selected_tv) = 2) {
            id(protocol_tv2) == 6;
            } else if (id(selected_tv) = 3) {
            id(protocol_tv3) == 6;
            } else if (id(selected_tv) = 4) {
            id(protocol_tv4) == 6}     

  - platform: template
    name: "Protocol Panasonic"
    id: P07
    on_press:
      then:
        - lambda: |-
            if (id(selected_tv) = 1) {
            id(protocol_tv1) == 7;
            } else if (id(selected_tv) = 2) {
            id(protocol_tv2) == 7;
            } else if (id(selected_tv) = 3) {
            id(protocol_tv3) == 7;
            } else if (id(selected_tv) = 4) {
            id(protocol_tv4) == 7}

  - platform: template
    name: "Protocol RAW/Pronto"
    id: P08
    on_press:
      then:
        - lambda: |-
            if (id(selected_tv) = 1) {
            id(protocol_tv1) == 8;
            } else if (id(selected_tv) = 2) {
            id(protocol_tv2) == 8;
            } else if (id(selected_tv) = 3) {
            id(protocol_tv3) == 8;
            } else if (id(selected_tv) = 4) {
            id(protocol_tv4) == 8}
            
# -------------------------------
# Botons: 20 funcions
# cadascun guarda l'índex i crida l'script principal
# -------------------------------
{% for i in range(1,21) %}
  - platform: template
    name: "Funció {{ '%02d' % i }}"
    on_press:
      then:
        - globals.set: { id: selected_function, value: '{{ i }}' }
        - script.execute: send_ir
{% endfor %}

# -------------------------------
# SCRIPT principal d'enviament
# -------------------------------
script:
  - id: send_ir
    mode: queued
    then:
      - lambda: |-
          ESP_LOGI("IR", "Funció=%d, TV=%d",
                   id(selected_function), id(selected_tv));

      # ------- RC6 (Philips) -------
      - if:
          condition:
            lambda: 'return id(selected_protocol) == 3;'
          then:
            - choose:
                # --- Selecció del transmissor segons TV ---
                - condition: { lambda: 'return id(selected_tv) == 1;' }
                  then:
                    - remote_transmitter.transmit_rc6:
                        transmitter_id: ir_tv1
                        address: 0x00   # Philips acostuma a 0x00
                        command: !lambda |-
                          // Mapa de 20 funcions -> comandes RC6 (TV1)
                          // Valors extrets del fil (Philips 65OLED803, RC6)  (PowerToggle=0x0C, Vol+=0x10, Vol-=0x11, Mute=0x0D, Ch+=0x20, Ch-=0x21, Up=0x58, Down=0x59, Left=0x5A, Right=0x5B, OK=0x5C, Home=0x54, Source=0x38, Menu=0x57, Exit=0x9F, Netflix=0x76, Stop=0x31, Play=0x2C, Pause=0x30, FF=0x28)
                          const uint8_t idx = id(selected_function);
                          static const uint8_t cmd[21] = {
                            0x00, // 0 (no s'usa)
                            0x0C, // 1  PowerToggle
                            0x10, // 2  VolumeUp
                            0x11, // 3  VolumeDown
                            0x0D, // 4  Mute
                            0x20, // 5  ChannelUp
                            0x21, // 6  ChannelDown
                            0x58, // 7  Up
                            0x59, // 8  Down
                            0x5A, // 9  Left
                            0x5B, // 10 Right
                            0x5C, // 11 OK
                            0x54, // 12 Home (SmartMenu)
                            0x38, // 13 Source
                            0x57, // 14 Menu
                            0x9F, // 15 Exit
                            0x76, // 16 Netflix
                            0x31, // 17 Stop
                            0x2C, // 18 Play
                            0x30, // 19 Pause
                            0x28  // 20 FastForward
                          };
                          return cmd[(idx <= 20) ? idx : 0];

                - condition: { lambda: 'return id(selected_tv) == 2;' }
                  then:
                    - remote_transmitter.transmit_rc6:
                        transmitter_id: ir_tv2
                        address: 0x00
                        command: !lambda |-
                          // TODO: Omple amb els codis RC6 per a la TV2
                          const uint8_t idx = id(selected_function);
                          static const uint8_t cmd[21] = {0};
                          return cmd[(idx <= 20) ? idx : 0];

                - condition: { lambda: 'return id(selected_tv) == 3;' }
                  then:
                    - remote_transmitter.transmit_rc6:
                        transmitter_id: ir_tv3
                        address: 0x00
                        command: !lambda |-
                          // TODO: Omple amb els codis RC6 per a la TV3
                          const uint8_t idx = id(selected_function);
                          static const uint8_t cmd[21] = {0};
                          return cmd[(idx <= 20) ? idx : 0];

                - condition: { lambda: 'return id(selected_tv) == 4;' }
                  then:
                    - remote_transmitter.transmit_rc6:
                        transmitter_id: ir_tv4
                        address: 0x00
                        command: !lambda |-
                          // TODO: Omple amb els codis RC6 per a la TV4
                          const uint8_t idx = id(selected_function);
                          static const uint8_t cmd[21] = {0};
                          return cmd[(idx <= 20) ? idx : 0];

      # ------- RC5 (exemple: HDMI inputs) -------
      - if:
          condition:
            lambda: 'return id(selected_protocol) == 2;'
          then:
            - choose:
                - condition: { lambda: 'return id(selected_tv) == 1;' }
                  then:
                    - remote_transmitter.transmit_rc5:
                        transmitter_id: ir_tv1
                        address: !lambda |-
                          // Exemple: HDMI inputs en Philips fan servir address 0x03
                          return 0x03;
                        command: !lambda |-
                          // Map: Funció 1..4 -> HDMI1..4; la resta 0
                          const uint8_t idx = id(selected_function);
                          static const uint8_t hdmi_cmd[21] = {
                            0x00, 0x06, 0x04, 0x08, 0x09, // 1..4
                            0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0
                          };
                          return hdmi_cmd[(idx <= 20) ? idx : 0];
                # TV2..4: replica i omple segons necessitis

      # ------- NEC (exemple) -------
      - if:
          condition:
            lambda: 'return id(selected_protocol) == 1;'
          then:
            - choose:
                - condition: { lambda: 'return id(selected_tv) == 1;' }
                  then:
                    - remote_transmitter.transmit_nec:
                        transmitter_id: ir_tv1
                        address: !lambda |-
                          // Exemple: "Signal" del fil (NEC address 0xFB04, command 0x6996)
                          return 0xFB04;
                        command: !lambda |-
                          const uint16_t map_nec[21] = {
                            0, 0x6996 /*1*/, 0,0,0, 0,0,0,0,0, 0,0,0,0,0, 0,0,0,0,0
                          };
                          const uint8_t idx = id(selected_function);
                          return map_nec[(idx <= 20) ? idx : 0];
                # TV2..4: replica i omple segons necessitis

      # ------- Placeholder per altres protocols (4..8) -------
      - if:
          condition:
            lambda: 'return id(selected_protocol) >= 4;'
          then:
            - logger.log: "Protocol no implementat (encara). Omple el bloc a l'script."
